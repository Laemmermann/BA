Nachdem nun die konzeptionellen Vorarbeiten geleistet sind, wird in diesem Kapitel die Implementierung des Hyperaudio-Plugins erläutert. Zu Beginn wird zunächst die grundlegende Architektur des Moodle-Plugins festgehalten. Daraufhin werden das Vorgehen und die Ergebnisse der Implementierung beleuchtet.

%%%%%%%%%%
\section{Architektur des Moodle-Plugins}
\label{sec:architektur}
Bei der Implementierung des Hyperaudio-Plugins ist die durch Moodle vorgegebene Architektur von Plugins zu beachten \citep{moodle2016activity}. Diese besteht stets aus vorgegebenen Dateien und Ordnen, wobei die jeweilige Anzahl von der Art des zu entwickelnden Plugins abhängig ist. Darüber hinaus bestimmt die Art des Plugins auch den zu wählenden Speicherort.

Bei Activity Plugins, wie dem Plugin für Hyperaudio-Dokumente, ist als Speicherort der Ordner \textbf{/mod} vorgeben. In diesem Ordner muss ein Unterordner mit dem Namen des Plugins angelegt werden, in diesem Fall \textbf{hyperaudio}, in welchem alle Plugin-Dateien abgelegt werden. Eine Übersicht über die Ordnerstruktur des Hyperaudio-Plugins findet sich in Abbildung \ref{fig:Ordnerstruktur}.

\begin{figure}[h!]
\includegraphics[width=0.3\textwidth,center]{Ordnerstruktur.PNG}
\caption{\label{fig:Ordnerstruktur}Ordnerstruktur des Hyperaudio-Plugins}
\end{figure}

\todo[inline]{Ordnerstruktur aktualisieren}

Der Ordner \textbf{/hyperaudio/db} beherbergt die Dateien \textbf{access.php}, \textbf{install.xml} und \textbf{upgrade.php}. Die Datei \textbf{access.php} dient zur Steuerung der Berechtigungen innerhalb des Moodle-Plugins, wobei den verschiedenen Moodle-Rollen verschiedene Rechte für die einzelnen Funktionen zugewiesen werden können. Bei der Installation des Plugins wird die \textbf{install.xml} zur Erstellung der Datenbanktabellen für das Plugin verwendet. Es ist mindestens eine Tabelle mit dem Namen des Plugins anzulegen. Sollten die Datenbanktabellen nach Veröffentlichung des Plugins um Spalten erweitert werden, so kommt die Datei \textbf{upgrade.php} zum Einsatz. Hierin werden die notwendigen Schritte für einen Versionsabgleich definiert.

Im Ordner \textbf{/hyperaudio/lang} wird die Sprachlokalisierung vorgenommen. Für jede Sprache wird innerhalb des \textbf{lang}-Ordners ein eigener Unterordner angelegt. Darin befindet sich jeweils eine PHP-Datei, in welcher die Übersetzungen definiert werden. Der Name dieser Datei entspricht wiederum dem Namen des Plugins.

Das Icon, welches für das Plugin  verwendet werden soll, muss im Ordner \textbf{/hyperaudio/pix} mit dem Dateinamen \textbf{icon.gif} abgelegt werden und sollte eine Auflösung von 16x16 Pixel besitzen.

Im Ordner \textbf{/hyperaudio} liegen darüber hinaus die Dateien \textbf{lib.php}, \textbf{mod\underline{{ }}form.php}, \textbf{index.php}, \textbf{view.php} und \textbf{version.php}.\\
Die \textbf{lib.php} dient dazu, Standardfunktionen von Moodle zu überschreiben, wobei \texttt{<pluginname>\underline{{ }}add\underline{{ }}instance}, \texttt{<pluginname>\underline{{ }}update\underline{{ }}instance} und \texttt{<pluginname>\underline{{ }}delete\underline{{ }}instance} als essenzielle Funktionen zu nennen sind. Mit diesen Funktionen wird das Anlegen, Aktualisieren und Löschen von Instanzen des Plugins ermöglicht.\\
Zum Anlegen und Aktualisieren wird in der \textbf{mod\underline{{ }}form.php} die dazugehörige Maske festgelegt.\\
Die \textbf{\textit{index.php}} dient der Auflistung aller Instanzen eines Plugins innerhalb eines Kurses, worüber sich somit eine statistische Ansicht für den jeweiligen Kurs definieren lässt. Je nach Umsetzung kann der Inhalt dieser Auflistung unterschiedlich viele Informationen zu den Instanzen bereitstellen. Auch ist es beispielsweise anhand der Berechtigungen aus der \textbf{access.php} möglich, gewisse Inforationen nur bestimmten Benutzern anzuzeigen.\\
Die erste Datei, die beim Öffnen der Aktivität geladen wird, ist die \textbf{view.php}, welche dementsprechend vornehmlich der Anzeige der Inhalte dient.\\
In der \textbf{version.php} wird die Version des Plugins gepflegt. Erhöht sich die Versionsnummer in der \textbf{version.php}, wird der automatische Upgradeprozess von Moodle für das Plugin ausgelöst.

Neben diesen vorgegebenen Dateien kommen üblicherweise noch weitere Dateien bei der Entwicklung eines Moodle-Plugins zum Einsatz \citep{wild2017moodle}. Dazu gehört beispielsweise die \textbf{locallib.php}, in welcher üblicherweise alle plugineigenen PHP-Funktionen deklariert werden. Auch ist es Usus, die eigentliche Darstellung der Plugin-Inhalte innerhalb eines Kurses von der \textbf{view.php} in eine \textbf{renderer.php} zu verlagern. Dort können verschiedene Renderer-Klassen, welche durch Moodle bereitgestellt werden, für die eigenen Bedürfnisse überschrieben werden. Anpassungen optischer Natur können durch CSS (Cascading Style Sheets) in der \textbf{styles.css} vorgenommen werden. Eigene JavaScript-Module, welche beispielweise beim Laden der \textbf{view.php} automatisch aufgerufen werden, sind im Verzeichnis \textbf{/hyperaudio/AMD} (Asynchronous Module Definition) abzulegen.

%%%%%%%%%%
\section{Iterative Entwicklung}
Die Entwicklung des Plugins wird in iterativer Form durchgeführt. In jeder Iteration soll das Plugin nur um einige wenige Funktionalitäten erweitert werden. Jede Iteration soll mit einem lauffähigen Plugin abgeschlossen werden. So kann direkt das Ergebnis betrachtet werden und gegebenenfalls in der nächsten Iteration nochmals angepasst werden \citep{augsten2018iterativ}. Die Reihenfolge, in welcher die Funktionalitäten umgesetzt werden, leitet sich aus der Priorisierung der Anforderungen aus Abschnitt \ref{sec:anforderungsdefinition} ab. In den folgenden Abschnitten werden nun die verschiedenen Iterationsschritte vorgestellt. Dabei werden die Kernkonzepte mithilfe von Codeauszügen erläutert. 

\subsection{Speichern und Abspielen einer Audio-Datei}
\label{sec:it1}
In der ersten Iteration wird zunächst die grundlegende Struktur des Plugins erstellt (vgl. Abschnitt \ref{sec:architektur}). Ziel der ersten Iteration soll es sein, eine Audio-Datei speichern und wiedergeben zu können.

Dazu wird in der Maske zum Anlegen und Aktualisieren von Instanzen des Hyperaudio-Plugins (\textbf{mod\underline{{ }}form.php}) neben dem obligatorischen Namens-Feld noch ein Element zum Hinzufügen einer Audio-Datei angelegt. Auflistung \ref{lst:it1:modform} zeigt einen Ausschnitt des Codes, der in der Funktion \texttt{definition} der Klasse \texttt{mod\underline{{ }}hyperaudio\underline{{ }}mod\underline{{ }}form}, die von der Klasse \texttt{moodleform\underline{{ }}mod} erbt, ergänzt werden muss. 

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{mod\underline{{ }}form.php} in der 1. Iteration},
             label={lst:it1:modform}]
$mform = $this->_form;
$mform->addElement('text', 'name', get_string('hyperaudio_mod_form_name',
    'hyperaudio'));
$mform->addHelpButton('name', 'hyperaudio_mod_form_name', 'hyperaudio');
$mform->setType('name', PARAM_TEXT);
$mform->addRule('name', get_string('error_wrong_hyperaudio_name_input',
    'hyperaudio'), 'required');
$mform->addElement('filemanager', 'audiofile', get_string('hyperaudiodata',
    'hyperaudio'), null,
    array(
        'subdirs' => 0,
        'maxbytes' => 0,
        'areamaxbytes' => 524288000,
        'maxfiles' => 1,
        'accepted_types' => array(
            'audio'
        )
    ));
$mform->addHelpButton('audiofile', 'hyperaudiodata', 'hyperaudio');
$mform->addRule('audiofile', get_string('required', 'hyperaudio'), 'required');
\end{lstlisting}

Der \texttt{\underline{{ }}form} der \texttt{moodleform\underline{{ }}mod} können durch \texttt{addElement} neue Form-Elemente hinzugefügt werden. Mithilfe der Funktionen \texttt{setType}, \texttt{addHelpButton} und \texttt{addRule} können den Elementen Datentypen, Hilfe-Button und Regeln zugewiesen werden, die bei Auswertung der Form automatisch validiert werden. Zum Hochladen von Dateien kann der \textit{filemanager} eingesetzt werden. Mithilfe eines Arrays können dabei Einschränkungen für Anzahl und Eigenschaften der hochzuladenden Dateien festgelegt werden. In diesem Fall darf maximal eine Datei hinzugefügt werden, die vom Typ \textit{audio} sein muss. Die Funktion \texttt{get\underline{{ }}string} dient im Allgemeinen der Darstellung der lokalisierten Bezeichnungen.

Um die Daten aus der Form in der Datenbank speichern und später wieder löschen zu können, muss auch die \textbf{lib.php} bearbeitet werden. Dazu dienen die bereits erwähnten Funktionen \texttt{<pluginname>\underline{{ }}add\underline{{ }}instance}, \texttt{<pluginname>\underline{{ }}update\underline{{ }}instance} und \texttt{<pluginname>\underline{{ }}delete\underline{{ }}instance}. Beispielhaft wird in Auflistung \ref{lst:it1:lib} die Funktion \texttt{hyperaudio\underline{{ }}add\underline{{ }}instance} zum Hinzufügen eines neuen Hyperaudio-Dokuments betrachtet. 

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{lib.php} in der 1. Iteration},
             label={lst:it1:lib}]
function hyperaudio_add_instance($data) {
    global $DB;
    
    $cmid = $data->coursemodule;
    $context = context_module::instance($cmid);
    
    $draftitemid_audiofile = $data->audiofile;
    unset($data->audiofile);
     
    $now = time();
    $data->timecreated = $now;
    $data->timemodified = $now;
    
    $data->id = $DB->insert_record('hyperaudio', $data);
    
    hyperaudio_update_audiofile($data->id, $context, $draftitemid_audiofile);
     
    return $data->id;
}
\end{lstlisting}

Der Parameter \texttt{\$data} enthält bereits die in der Form eingegebenen Daten. Das Attribut \mbox{\texttt{audiofile}} enthält nicht die Audio-Datei selbst, sondern die ID der \textit{draft file area} und soll im ersten Schritt nicht in der Tabelle \textit{hyperaudio} abgespeichert werden (vgl. Zeilen 7-8). Vor dem Speichern wird noch der aktuelle Zeitstempel hinterlegt (vgl. Zeilen 10-12). Mithilfe der Funktion \mbox{\texttt{\$DB->insert\underline{{ }}record}} kann das \texttt{\$data}-Objekt mit seinen Attributen in der Tabelle \textit{hyperaudio} abgelegt werden. Im Nachhinein sorgt die in der \textbf{locallib.php} definierte Funktion \mbox{\texttt{hyperaudio\underline{{ }}update\underline{{ }}audiofile}} dafür, dass die Audio-Datei in der \textit{files}-Tabelle abgespeichert und in der \textit{hyperaudio}-Tabelle korrekt referenziert wird (vgl. Auflistung \ref{lst:it1:locallib}).

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{locallib.php} in der 1. Iteration},
             label={lst:it1:locallib}]
function hyperaudio_update_audiofile($hyperaudioid, $context, $draftitemid) {
    global $DB;
    
    file_save_draft_area_files($draftitemid, $context->id, 'mod_hyperaudio',
        'audiofile', $hyperaudioid);
    $fs = get_file_storage();
    $files = $fs->get_area_files($context->id, 'mod_hyperaudio', 'audiofile',
        $hyperaudioid, 'itemid, filepath, filename', false);

    $file = reset($files);
    $DB->set_field('hyperaudio', 'audiofile', $file->get_filename(), array(
        'id' => $hyperaudioid
    ));
}
\end{lstlisting}

Wie bereits in Abschnitt \ref{sec:architektur} angedeutet, übernimmt die \textbf{renderer.php} die Anzeige der Hyperaudio-Inhalte (siehe Auflistung \ref{lst:it1:renderer}). Die \textbf{view.php} dagegen reduziert sich auf wenige Zeilen (vgl. Auflistung \ref{lst:it1:view}). Der Plugin-Renderer wird hier benutzt, um Header, Hauptinhalte und Footer anzuzeigen.

\begin{lstlisting}[language=php,
deletekeywords={header},
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{view.php} in der 1. Iteration},
             label={lst:it1:view}]
$output = $PAGE->get_renderer('mod_hyperaudio');
echo $output->header();
echo $output->display($hyperaudio, $context);
echo $output->footer();
\end{lstlisting}

In der Funktion \texttt{display} der Klasse \mbox{\texttt{mod\underline{{ }}hyperaudio\underline{{ }}renderer}}, die von der Klasse \mbox{\texttt{plugin\underline{{ }}renderer\underline{{ }}base}} erbt, werden die HTML-Inhalte erzeugt. Dabei handelt es sich in der ersten Iteration um einen Container, der ein \texttt{<audio>}-Element beinhaltet. Als Quelle wird im \texttt{<source>}-Element eine URL (Uniform Resource Locator) angegeben, die zuvor mit Moodle-Standardmitteln erzeugt wurde und auf die in der Datenbank abgelegte Audio-Datei verweist.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{renderer.php} in der 1. Iteration},
             label={lst:it1:renderer}]
$audio_fileinfo = array(
    'component' => 'mod_hyperaudio',
    'filearea' => 'audiofile',
    'itemid' => $hyperaudio->id,
    'contextid' => $context->id,
    'filepath' => '/',
    'filename' => $hyperaudio->audiofile
);

$audiofileurl = moodle_url::make_pluginfile_url(
    $audio_fileinfo['contextid'], $audio_fileinfo['component'],
    $audio_fileinfo['filearea'], $audio_fileinfo['itemid'],
    $audio_fileinfo['filepath'], $audio_fileinfo['filename']);
$audio_url = $audiofileurl->get_scheme() . '://' . $audiofileurl->get_host() .
    $audiofileurl->get_path();
if ($audiofileurl->get_port()){
    $audio_url .= ':' . $audiofileurl->get_port();
}
$output = '<div id="hyperaudio" 
    data-hyperaudio_id="'.$hyperaudio->id.'"
    data-context_id="'.$context->id.'"
    data-hyperaudio_titel="'.$hyperaudio->name.'"
    data-hyperaudio_author="'.$hyperaudio->author.'"
    data-hyperaudio_description="'.$hyperaudio->intro.'">';
$output .= '<audio id="hyperaudio_audio" controls>' .
    '<source src="' . $audio_url . '"/>' .
    '</audio>';
$output .= '</div>';

echo $output;
\end{lstlisting}

Auf die beschriebene Art und Weise lässt sich ein Hyperaudio-Dokument, das vorläufig allein aus einer Audio-Datei besteht, speichern und mithilfe des HTML5-Audio-Players wiedergeben.


\subsection{Speichern und Anzeige von Zusatzinhalten}
Bei der zweiten Iteration wird das Plugin um die Möglichkeit zum Speichern und zeitabhängigen Anzeigen der Zusatzinhalte erweitert. Für das Speichern wird analog zu Abschnitt \ref{sec:it1} vorgegangen. Es wird ein \textit{filemanager} (\textbf{mod\underline{{ }}form.php}) ergänzt, welcher das Hochladen von beliebig vielen Bilddateien erlaubt. Zusätzlich wird die \textbf{locallib.php} um die Funktionen \mbox{\texttt{hyperaudio\underline{{ }}update\underline{{ }}additional\underline{{ }}content}} und \mbox{\texttt{hyperaudio\underline{{ }}delete\underline{{ }}additional\underline{{ }}content}} erweitert. Die Löschfunktion soll verhindern, dass beispielsweise beim Ergänzen von Zusatzinhalten die bereits vorhanden Zusatzinhalte doppelt abgespeichert werden. Dementsprechend wird diese Funktion, wie in Auflistung \ref{lst:it2:locallib} zu sehen, zu Beginn der Funktion \mbox{\texttt{hyperaudio\underline{{ }}update\underline{{ }}additional\underline{{ }}content}} aufgerufen. Die Zeilen 22 bis 27 dienen dazu, die Metadaten des Zusatzinhaltes festzuhalten. In dieser Iteration werden diese noch mit fixen Beispieldaten befüllt. Die Funktion \mbox{\texttt{hyperaudio\underline{{ }}update\underline{{ }}additional\underline{{ }}content}} wird nun von den Funktionen \texttt{hyperaudio\underline{{ }}add\underline{{ }}instance} und \texttt{hyperaudio\underline{{ }}update\underline{{ }}instance} aufgerufen.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{locallib.php} in der 2. Iteration},
             label={lst:it2:locallib}]
function hyperaudio_update_additional_content
    ($hyperaudioid, $context, $draftitemid, $configfile) {
    global $DB;
    
    hyperaudio_delete_additional_content($hyperaudioid, $context);
    
    file_save_draft_area_files($draftitemid, $context->id,
        'mod_hyperaudio', 'additional_content', $hyperaudioid);
    $fs = get_file_storage();
    
    $files = $fs->get_area_files($context->id, 'mod_hyperaudio',
        'additional_content', $hyperaudioid, 'itemid, filepath, filename',
        false);
    $counter=1;
    $begin=0;
    $end=10;
    foreach ($files as $file) {        
        $additional_content = new \stdClass();
        $additional_content->file = $file->get_filename();
        $additional_content->hyperaudio_id = $hyperaudioid;
        
        $additional_content->name = 'Name '.$counter;
        $additional_content->course_unit = 'Kurseinheit '.$counter;
        $additional_content->page = 'Seite '.$counter;
        $additional_content->description = 'Beschreibung '$counter;
        $additional_content->begin = $begin;
        $additional_content->end = $end;
        
        $now = time();
        $additional_content->timecreated = $now;
        $additional_content->timemodified = $now;
        
        $additional_content_id = $DB->insert_record('additional_content',
            $additional_content);
		
        $counter++;
        $begin+=15;
        $end+=15;
    }
}
\end{lstlisting}

Um die gespeicherten Zusatzinhalte zeitabhängig anzeigen zu können, kommt nun das JavaScript-Framework \textit{Popcorn.js} zum Einsatz. Dazu werden die JavaScript-Dateien von \textit{Popcorn.js} und dessen \textit{Images}-Plugin im Ordner \textbf{/hyperaudio/thirdparty} abgelegt und in die \textbf{view.php} eingebunden (siehe Auflistung \ref{lst:it2:view}).

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{view.php} in der 2. Iteration},
             label={lst:it2:view}]
$PAGE->requires->js('/mod/hyperaudio/thirdparty/popcorn.js', true);
$PAGE->requires->js('/mod/hyperaudio/thirdparty/popcorn.image.js', true);
\end{lstlisting}

Im Renderer wird ein weiteres \texttt{<div>}-Element ergänzt, in welchem die Zusatzinhalte angezeigt werden sollen. Diese werden aus der Datenbank geladen und in einer Schleife abgearbeitet. Dabei wird zunächst eine URL zur Bilddatei generiert. Über \texttt{popcorn.image} sorgt das \textit{Popcorn.js} \textit{Images}-Plugin dafür, dass diese URL zu den definierten Zeitpunkten abgerufen und das entsprechende Bild angezeigt wird (vgl. Zeilen 46-51).

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{renderer.php} in der 2. Iteration},
             label={lst:it2:renderer}]
$output = '<div id="hyperaudio" data-hyperaudio_id="'.$hyperaudio->id.'">';
$output .= '<div id="hyperaudio_additional_content"></div>';
$output .= '<audio id="hyperaudio_audio" controls>' .
    '<source src="' . $audio_url . '"/>' . '</audio>';

$output .= '<script type="text/javascript">' .
    'document.addEventListener("DOMContentLoaded", function() {' .
        'var popcorn = Popcorn("#hyperaudio_audio");';

$files = hyperaudio_get_additional_content($hyperaudio->id, $context);
foreach ($files as $file) {
    $additional_content = $DB->get_record('additional_content',
        array(
            'hyperaudio_id' => $hyperaudio->id,
            'file' => $file->get_filename()
	    ),
        '*', IGNORE_MISSING);
	
    if ($additional_content == false){
        continue;
	}
	
    $additional_content_fileinfo = array(
        'component' => 'mod_hyperaudio',
        'filearea' => 'additional_content',
        'itemid' => $hyperaudio->id,
        'contextid' => $context->id,
        'filepath' => '/',
        'filename' => $additional_content->file
    );
	
    $additional_content_fileurl = moodle_url::make_pluginfile_url(
        $additional_content_fileinfo['contextid'],
        $additional_content_fileinfo['component'],
        $additional_content_fileinfo['filearea'],
        $additional_content_fileinfo['itemid'],
        $additional_content_fileinfo['filepath'],
        $additional_content_fileinfo['filename']);
        $additional_content_url = $additional_content_fileurl->get_scheme() . '://' .
        $additional_content_fileurl->get_host() . 
        $additional_content_fileurl->get_path();
    if ($additional_content_fileurl->get_port()){
        $additional_content_url .= ':' . $additional_content_fileurl->get_port();
    }
	
    $output .= 'popcorn.image({
        start: '.$additional_content->begin.',
        end: '.$additional_content->end.',
        href: "javascript:void(0);",
        src: "'.$additional_content_url.'",
        target: "hyperaudio_additional_content"});';
}

$output .= '}, false);</script>';
$output .= '</div>';

echo $output;
\end{lstlisting}

Mit diesen Erweiterungen wurde das Ziel der zweiten Iteration erreicht. Es ist nun möglich, Zusatzinhalte abzuspeichern und diese unter Verwendung von \textit{Popcorn.js} zeitabhängig zur Audio-Datei darstellen zu lassen.

\subsection{Einbindung der Konfigurationsdatei}
Damit die Beispieldaten durch tatsächliche Metadateninformationen ausgetauscht werden können, ist in der dritten Iteration die Einbindung der Konfigurationsdatei notwendig. Zu Beginn dieser Iteration steht erneut die Erweiterung der \textbf{mod\underline{{ }}form.php} um einen weiteren \textit{filemanager}, der maximal eine Konfigurationsdatei im JSON-Format entgegennimmt. Neben den nötigen Anpassungen in der \textbf{lib.php} wird auch die Funktion \texttt{hyperaudio\underline{{ }}update\underline{{ }}additional\underline{{ }}content} erweitert (siehe Auflistung \ref{lst:it3:locallib}).



Die Speicherung verläuft analog zur Speicherung der Zusatzinhalte. In diesem Zuge wird also erneut die \textbf{lib.php} und \textbf{locallib.php} entsprechend erweitert. Neben den Funktionen \texttt{hyperaudio\underline{{ }}update\underline{{ }}hyperaudio\underline{{ }}config} und \texttt{hyperaudio\underline{{ }}delete\underline{{ }}hyperaudio\underline{{ }}config} wird, wie in Auflistung \ref{lst:it3:locallib} zu erkennen, die Funktion \texttt{hyperaudio\underline{{ }}update\underline{{ }}additional\underline{{ }}content} erweitert. Es ist zu entnehmen, dass zunächst die Inhalte der Konfigurationsdatei mithilfe der Funktion \texttt{parse\underline{{ }}hyperaudio\underline{{ }}config} ausgelesen werden, um diese Metadaten dann beim Abspeichern der Zusatzinhalte zu verwenden.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{locallib.php} in der 3. Iteration},
             label={lst:it3:locallib}]
hyperaudio_update_additional_content($hyperaudio_id, $context,
    $draftitemid, $configfile){
	
    //...
	
    $additional_contents_data = 
        hyperaudio_parse_hyperaudio_config($hyperaudioid, $context, $configfile)
                ["additional_contents_by_filename"];;
    
    //...
	
    foreach ($files as $file) {        
        //...
        
        $additional_content_data =
            $additional_contents_data[$additional_content->file];
        
        $additional_content->name = $additional_content_data->name;
        $additional_content->course_unit = $additional_content_data->course_unit;
        $additional_content->page = $additional_content_data->page;
        $additional_content->description = $additional_content_data->description;
        $additional_content->begin = $additional_content_data->begin;
        $additional_content->end = $additional_content_data->end;
        
        //...
    }    
}

//...

function hyperaudio_parse_hyperaudio_config($hyperaudio_id, $context, $configfile) {
    
    $fs = get_file_storage();
    $file = $fs->get_file(
        $context->id, 'mod_hyperaudio', 'hyperaudio_config',
        $hyperaudio_id, '/', $configfile);
    $jsontext = $file->get_content();
    $json = json_decode ($jsontext);
    
    $hyperaudio_author = $json->author;
    
    $additional_contents = $json->additional_contents->additional_content;
    $additional_contents_by_filename =
        array_column($additional_contents, NULL, 'filename');
    
    return array(
        'additional_contents_by_filename' => $additional_contents_by_filename,
        'hyperaudio_author' => $hyperaudio_author);
}
\end{lstlisting}



Als Ergebnis dieser Iteration können nun Zusatzinhalte zu den Zeitpunkten dargestellt werden, welche in der Konfigurationsdatei definiert sind.

\subsection{Speichern und Anzeige von Kommentaren}
\label{sub:SpeichernKommentare}
Nachdem in den vorherigen Iterationen die Pflege und das Abspielen von Hyperaudio-Dokumenten im Fokus lag, konzentriert sich diese Iteration auf die Kommentarfunktion. Zu diesem Zweck wird im ersten Schritt der Renderer um entsprechende Elemente ergänzt, welche in Auflistung \ref{lst:it4:renderer} zu sehen sind. Dabei handelt es sich zum einen um eine Textarea mit dazugehörigem Submit-Button, welche dem Erstellen von Kommentaren dienen. Das \texttt{<div>}-Element mit der ID \mbox{\textit{hyperaudio\underline{{ }}comments}} soll der Anzeige der Kommentare dienen.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{renderer.php} in der 4. Iteration},
             label={lst:it4:renderer}]
$output .=
    '<div id="comment_creation_container" class="textarea_container">
        <textarea id="hyperaudio_comment" name="hyperaudio_comment"
            class="hyperaudio_textarea" autocomplete="off"
            placeholder="
                '.get_string('mod_hyperaudio_renderer_comment', 'hyperaudio')
            .'...'.'">
        </textarea>
        <button type="button" class="comment_submit"
            data-comment_type="'.CommentType::Comment.'">
            '.get_string('mod_hyperaudio_renderer_submit_comment', 'hyperaudio').'
        </button>
    </div>';
$output .= '<div id="hyperaudio_comments"></div>';
\end{lstlisting}

Das Speichern sowie das Anzeigen der Kommentare wird unter Einsatz von Webservices, welche durch ein JavaScript-Modul (\textbf{/hyperaudio/AMD/src/hyperaudio.js}) angesprochen werden, realisiert. Hierfür werden zusätzlich die Dateien \textbf{services.php} (\textbf{/hyperaudio/db}) und \textbf{external.php} (\textbf{/hyperaudio/classes}) für die Bereitstellung der Webservices benötigt.
\todo[inline]{Wie ist Annotationszeitpunkt definiert?}

In der \textbf{services.php} werden zunächst die nötigen Webservices deklariert (siehe Auflistung \ref{lst:it4:services}). Hier wird lediglich auf die \textbf{external.php} verwiesen, die den eigentlichen Code der Webservices beinhalten.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={\textbf{services.php} in der 4. Iteration},
             label={lst:it4:services}]
$functions = array(
    'mod_hyperaudio_save_comment' => array(
        'classname'   => 'mod_hyperaudio_external',
        'methodname'  => 'save_comment',
        'classpath'   => 'mod/hyperaudio/classes/external.php',
        'description' => 'Save comment',
        'type'        => 'write'
    ),
    'mod_hyperaudio_load_comments' => array(
        'classname'   => 'mod_hyperaudio_external',
        'methodname'  => 'load_comments',
        'classpath'   => 'mod/hyperaudio/classes/external.php',
        'description' => 'Load comments',
        'type'        => 'read'
    )
);
\end{lstlisting}

In der \textbf{external.php} werden in der Funktion \texttt{mod\underline{{ }}hyperaudio\underline{{ }}external}, welche von der Klasse \texttt{external\underline{{ }}api} erbt, die Webservice-Funktionen definiert. Dabei sind für einen Webservice jeweils vier Funktionen von Nöten:

\begin{itemize}
\item \texttt{<webservice\underline{{ }}name>\underline{{ }}parameters}: definiert die Eingabe-Parameter des Webservices
\item \texttt{<webservice\underline{{ }}name>\underline{{ }}is\underline{{ }}allowed\underline{{ }}from\underline{{ }}ajax}: definiert, ob der Webservice über AJAX (Asynchronous JavaScript and XML) aufgerufen werden kann
\item \texttt{<webservice\underline{{ }}name>}: Hauptfunktion, welche die Eingabe-Parameter verarbeitet und ein Ergebnis zurückliefert
\item \texttt{<webservice\underline{{ }}name>\underline{{ }}returns}: definiert die Struktur der Rückgabewerte des Webservices
\end{itemize}

Auflistung \ref{lst:it4:external} zeigt exemplarisch die Umsetzung des Webservices \texttt{load\underline{{ }}comments}. Anhand der übergebenen \texttt{\$hyperaudio\underline{{ }}id} werden die Kommentare mittels SQL (Structured Query Language) aus der Datenbank gelesen und in einer aufbereiteten Struktur zurückgegeben.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{external.php} in der 4. Iteration},
             label={lst:it4:external}]
class mod_hyperaudio_external extends external_api {
    
    public static function load_comments_parameters() {
        return new external_function_parameters(
            array(
            'hyperaudio_id' => new external_value(PARAM_INT, 'hyperaudio_id')
            )
        );
    }
    
    public static function load_comments_is_allowed_from_ajax() {
        return true;
    }
    
    public static function load_comments($hyperaudio_id) {
        global $CFG, $DB;
        
        require_once ($CFG->dirroot . '/mod/hyperaudio/locallib.php');
        require_once ($CFG->dirroot . '/mod/hyperaudio/classes/enums.php');
        
        $comments = $DB->get_records_sql(
            'SELECT comments.id, comments.comment_type,
            comments.commenttext, comments.timeannotated,
            comments.timecreated, user.username'.
            ' FROM mdl_hyperaudio_comments comments'.
            ' INNER JOIN mdl_user user ON comments.userid = user.id'.
            ' WHERE comments.hyperaudio_id = ?'.
            ' AND (comments.comment_type = ? )'.
            ' ORDER BY comments.timecreated',
            array($hyperaudio_id, CommentType::Comment)
        );
        
        $result_comments = array();
        foreach ($comments as $comment) {
            $result_comment = array(
                'id' => $comment->id,
                'username' => $comment->username,
                'date' => date('d.m.Y H:i', $comment->timecreated),
                'time' => format_time_annotated($comment->timeannotated),
                'text' => $comment->commenttext,
                'comment_type' => $comment->comment_type
            );
            $result_comments[] = $result_comment;
        }
        
        return $result_comments;
    }
    
    public static function load_comments_returns() {
        return new external_multiple_structure(
            new external_single_structure(
                array(
                    'id' => new external_value(PARAM_INT, 'id'),
                    'username' => new external_value(PARAM_TEXT, 'username'),
                    'date' => new external_value(PARAM_TEXT, 'date'),
                    'time' => new external_value(PARAM_TEXT, 'time'),
                    'text' => new external_value(PARAM_TEXT, 'text'),
                    'comment_type' => new external_value(PARAM_TEXT, 'comment_type')
                )
            )
        );
    }
}             
\end{lstlisting}

Für den Zugriff auf die Webservices wird das JavaScript-Modul \textbf{hyperaudio.js}, welches sich im Ordner \textbf{/hyperaudio/AMD} befindet, eingeführt. Das Modul dient dazu die im Renderer definierten Elemente zu befüllen beziehungsweise auszulesen.
Die Funktion zum Speichern eines Kommentars ist exemplarisch in Auflistung \ref{lst:it4:hyperaudio} dargestellt. Zunächst werden die im Renderer erstellten Elemente zum Erstellen eines Kommentars ausgelesen. Um Funktionen die mehrfach benötigt werden, wie die Funktion \texttt{get\underline{{ }}hyperaudio\underline{{ }}id},  auszugliedern, wird die Datei \textbf{locallib.js} im Ordner \textbf{/hyperaudio/thirdparty} implementiert. Nachdem die Elemente ausgelesen wurden, wird mittels eines AJAX-Calls der Webservice \texttt{mod\underline{{ }}hyperaudio\underline{{ }}save\underline{{ }}comment} aufgerufen und die benötigten Parameter übergeben. Hierbei ist hervorzuheben, dass der Zeitpunkt, zu dem der Kommentar an das Hyperaudio-Dokument annotiert wird, über die Funktion \texttt{currentTime} des \textit{Popcorn.js}-Frameworks ermittelt werden kann. Bei der Funktion \texttt{show\underline{{ }}comments} zum Darstellen der Kommentare wird analog vorgegangen, nur dass durch den Webservice die Kommentare für das betroffene Hyperaudio-Dokumente abgefragt und innerhalb des dazugehörigen Elements des Renderers dargestellt werden.


\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{hyperaudio.js} in der 4. Iteration},
             label={lst:it4:hyperaudio}]
function save_comment(comment_type){
    var comment = $("#hyperaudio_comment").val();
    var hyperaudio_id = get_hyperaudio_id();
    var popcorn = Popcorn("#hyperaudio_audio");
    var timeannotated = popcorn.currentTime();
    timeannotated = parseInt(timeannotated);
	    
    var promises = ajax.call([{
        methodname: 'mod_hyperaudio_save_comment',
        args:{
            'comment': comment,
            'hyperaudio_id': hyperaudio_id,       
            'timeannotated': timeannotated,
            'comment_type': comment_type
        }
    }]);
    promises[0].done(function(data) {
        show_comments();
    });
}
\end{lstlisting}

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{locallib.js} in der 4. Iteration},
             label={lst:it4:locallib.js}]
function get_hyperaudio_id(){
    return $("#hyperaudio").attr("data-hyperaudio_id");
}
function jump_to_time(element){
    var time = $(element).attr("data-annotated_time");
    var popcorn = get_popcorn();
    popcorn.currentTime(time);
    popcorn.play();
}
\end{lstlisting}

In der \textbf{locallib.js} ist darüber hinaus mit \texttt{jump\underline{{ }}to\underline{{ }}time} eine Funktion enthalten, mit welcher die Rückkopplung an die Mediensteuerung ermöglicht wird.

Mit dem Abschluss dieser Iteration wurde die Möglichkeit geschaffen, Kommentare zu verfassen und dabei den Zeitpunkt innerhalb des Hyperaudio-Dokuments festzuhalten, zu dem der Kommentar erstellt wurde. Im gleichen Zuge wurde auch die Darstellung dieser Kommentare ermöglicht.

\subsection{Antworten auf Kommentare}
Im nächsten Schritt soll nun eine Antwortmöglichkeit auf Kommentare geschaffen werden. Zu diesem Zweck wird ein neuer Webservices zum Speichern von Antworten erstellt und der Webservice zum Darstellen der Kommentare um Antworten erweitert. Bei der \textbf{hyperaudio.js} bedarf es ebenfalls nur kleinerer Anpassungen, unter anderem die Anzeige eines Antworten-Buttons und eines Textfeldes bei dessen Betätigung zu ermöglichen (siehe Abbildung \ref{fig:Antworten}). Die hierfür notwendige Erweiterung innerhalb der Funktion \texttt{show\underline{{ }}comments} ist in der Auflistung \ref{lst:it5:hyperaudio} zu sehen.

\begin{figure}[h!]
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.95\textwidth,center]{Antworten1.png}
\label{fig:Antworten1}
\end{subfigure}%
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.95\textwidth,center]{Antworten2.png}
\label{fig:Antworten2}
\end{subfigure}
\caption{Darstellung der Antworten-Funktion}
\label{fig:Antworten}
\end{figure}

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{hyperaudio.js} in der 5. Iteration},
             label={lst:it5:hyperaudio}]
if (this.comment_type === CommentType.Comment && !this.comment_id){
    output = output + '<div 
        class="comment_answer comment_actions" 
        data-comment_id="'+this.id+'">';
    output = output + '<a href="javascript:void(0);"
        class="comment_answer_link comment_link active" 
        onclick="show_answer_textarea(this)" 
        data-comment_id="'+this.id+'">' + string_answer + '</a>';
    output = output + '<div class="textarea_container">';
    output = output + '<textarea 
        class="comment_answer_text comment_hidden_element hyperaudio_textarea" 
        data-comment_id="'+this.id+'" ' + 
        'placeholder="' + string_answer + '...' + '"/>';
    output = output + '<button type="button" 
        class="comment_answer_button comment_hidden_element
        hyperaudio_comment_button" 
        data-comment_id="'+this.id+'">' + string_answer + '</button>';
    output = output + '</div>';
    output = output + '</div>';
\end{lstlisting}

Durch die Erweiterungen und Anpassungen innerhalb dieser Iteration ist es nun möglich auf Kommentare zu antworten und diese Antwort beim zugehörigen Kommentar darzustellen.

\subsection{Notizen}
\label{sub:notizen}
Nachdem durch die vorangegangenen Iterationen nun die Funktionen für die Kommunikation zwischen Studierenden und Lehrenden geschaffen wurden, zielt diese Iteration auf das Erstellen und Darstellen von Notizen ab.

Zum Speichern der Notizen können dieselben Webservices und Funktionen, wie zum Speichern der Kommentare verwendet werden. Dies rührt daher, dass Notizen eine bestimmte Art von Kommentaren darstellen (vgl. Abschnitt \ref{sec:komponenten_zusammenhaenge}). 

Da Notizen im Gegensatz zu Kommentaren geändert und gelöscht werden können sollen, müssen hierfür entsprechende Webservices bereitgestellt werden. Gleichzeitig müssen analog zum Antworten auf Kommentare ein Button zum Löschen sowie Button und Textfeld für die Bearbeitung der Notiz ergänzt werden.

\begin{figure}[h!]
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.95\textwidth,center]{Notiz1.png}
\label{fig:Notiz1}
\end{subfigure}%
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.95\textwidth,center]{Notiz2.png}
\label{fig:Notiz2}
\end{subfigure}
\caption{Darstellung der Notiz-Funktion}
\label{fig:Notiz}
\end{figure}

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{hyperaudio.js} in der 6. Iteration},
             label={lst:it6:hyperaudio}]
else if (this.comment_type === CommentType.Note){
    output = output + '<div
        class="comment_note comment_actions" data-comment_id="'+this.id+'">';
    output = output + '<a href="javascript:void(0);"
        class="comment_note_edit_link comment_link active"
        onclick="show_note_edit_textarea(this)"
        data-comment_id="'+this.id+'">' + string_edit + '</a>';
    output = output + '<a href="javascript:void(0);"
        class="comment_note_delete_link comment_link active"
        data-comment_id="'+this.id+'">' + string_delete + '</a>';
    output = output + '<div class="textarea_container">';
    output = output + '<textarea
        class="comment_note_edit_text comment_hidden_element hyperaudio_textarea"
        data-comment_id="'+this.id+'">' + this.text + '</textarea>';
    output = output + '<button type="button"
        class="comment_note_edit_button comment_hidden_element
            hyperaudio_comment_button"
        data-comment_id="'+this.id+'">' + string_edit + '</button>';
    output = output + '</div>';
    output = output + '</div>';
}		
\end{lstlisting}

Entsprechend der Webservices werden innerhalb der \textbf{external.php} Funktionen zum Editieren von Notizen und dem Löschen von Kommentaren erstellt. Damit sind alle nötigen Schritte durchgeführt um Notizen erstellen, anzeigen und löschen zu können.


\subsection{Audio Cues}
Das Abspielen der Audio Cues im Moment der Darstellung eines Zusatzinhaltes wird durch eine Erweiterung des verwendeten \textit{Popcorn.js}-Plugin \textit{Images} erreicht. In diesem Zug wird das \textit{Popcorn.js}-Plugin \textit{Hyperaudio} basierend auf dem \textit{Images}-Plugin entwickelt.

Hierfür wird in den Optionen ein zusätzlicher Parameter \texttt{cue} eingeführt. Dieser nimmt die ID eines \texttt{<audio>}-Elements entgegen, welches den abzuspielenden Audio Cue wiedergeben kann (vgl. Auflistung \ref{lst:it7:renderer}). Um den Ton zeitgleich mit der Anzeige des Zusatzinhaltes abzuspielen, wird eine Anpassung in der Funktion \texttt{start} vorgenommen. Sofern keine Stummschaltung oder Pausierung des Hyperaudio-Dokuments vorliegt, wird die Wiedergabe des Audio Cues durch den Aufruf der \texttt{play}-Funktion des HTML5-Audioplayers angestoßen. Auflistung \ref{lst:it7:popcorn.hyperaudio} zeigt die Erweiterungen des \textit{Popcorn.js}-Plugins \textit{Hyperaudio}.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{renderer.php} in der 7. Iteration},
             label={lst:it7:renderer}]
$output .= '<audio id="hyperaudio_audio_cue" src="../hyperaudio/ding.mp3"></audio>';
\end{lstlisting}

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{popcorn.hyperaudio.js} in der 7. Iteration},
             label={lst:it7:popcorn.hyperaudio}]
options: {

    //...
    
    cue: "audio-cue",

    //...    
    
}

//...

start: function( event, options ) {
    options.anchor.style.display = "inline";
    if ( options.trackedContainer ) {
        options.trackedContainer.start();
    }
    var audioElement = document.getElementById( options.cue );
    if (!this.media.muted && !this.media.paused){
        audioElement.play();
    }
},
\end{lstlisting}

Durch die Weiterentwicklung des \textit{Images}-Plugins zum \textit{Popcorn.js}-Plugin \textit{Hyperaudio} wurde in dieser Iteration die Wiedergabe von Audio Cues beim Anzeigen von Zusatzinhalten implementiert.

\subsection{Galerie der Zusatzinhalte}
Der Anforderung nach einer Übersicht über annotierte Zusatzinhalte wird mittels einer Galerie begegnet, welche in dieser Iteration umgesetzt wird. Hierfür werden in der \textbf{renderer.php} zunächst die Metainformationen zu allen Zusatzinhalten des Hyperaudio-Dokuments geladen, um anhand dieser im nächsten Schritt URLs zu den Zusatzinhalten zu generieren. Damit wird eine Darstellung gemäß der Idee aus Abbildung \ref{fig:MockupGalerieFinal} umgesetzt (siehe Abbildung \ref{fig:Galerie}). Die Rückkopplung zur Mediensteuerung erfolgt wie bereits bei den Kommentaren mithilfe der \texttt{jump_to_time}-Funktion.

\begin{figure}[h!]
\includegraphics[width=0.8\textwidth,center]{Galerie.png}
\caption{\label{fig:Galerie}Darstellung der Galerie}
\end{figure}


Um eine vergrößerte Darstellung der Zusatzinhalte zu realisieren, wird ein versteckter Bereich angelegt. Beim Klick auf ein Vorschaubild wird mithilfe der Funktion \texttt{show\underline{{ }}modal} der entsprechende Zusatzinhalt in diesen Bereich geladen und dargestellt (vgl. Auflistung \ref{lst:it8:hyperaudio}). 

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{hyperaudio.js} in der 8. Iteration},
             label={lst:it8:hyperaudio}]
function show_modal(source, caption){
    $("#hyperaudio_modal_image").attr("src", source);
    $("#hyperaudio_modal_caption").html(caption);
    $("#hyperaudio_modal").css("display", "block");
}
\end{lstlisting}

Durch diese Implementierung wird die Darstellung der Galerie erreicht, durch Verwendung der JavaScript-Funktion \texttt{jump\underline{{ }}to\underline{{ }}time} wird zusätzlich noch die Rückkopplung an die Mediensteuerung geboten. 

\subsection{Zeitabhängige Visualisierung der Kommentare und Notizen}
In dieser Iteration soll sich nun der zeitabhängigen Visualisierung der Kommentare und Notizen zugewendet werden. An dieser Stelle muss festgehalten werden, dass dies beim Einsatz des Standard HTML5-Audioplayers schwer umsetzbar ist, weshalb auf die Erkenntnisse bezüglich des \textit{VideoJS Players} aus Abschnitt \ref{sub:TechnologienMoodle} zurückgegriffen wird. Die umfassenden Anpassungsmöglichkeiten sollen sich nun in dieser Iteration zu Nutze gemacht werden.

Im ersten Schritt werden zunächst die benötigten Informationen für die Darstellung der in Abbildung \ref{fig:MockupMediensteuerungV3} beschriebenen Blöcke aus der Datenbank abgerufen. Hierfür wird ein neuer Webservice eingeführt und unter anderem  die \textbf{external.php} erweitert.

Um die ermittelten Informationen darzustellen, wird, wie in Auflistung \ref{lst:it9:hyperaudio} zu erkennen, der Webservice von der Funktion \texttt{show\underline{{ }}timeline} der \textbf{hyperaudio.js} aufgerufen und darauf die Größe der Blöcke unter Berücksichtigung der Größe der Timeline berechnet. Dabei wird auf vorhandene HTML Elemente des \textit{VideoJS Players} zurückgegriffen, um die gewünschte Darstellung der Blöcke ober- und unterhalb der Timeline zu erreichen.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{hyperaudio.js} in der 9. Iteration},
             label={lst:it9:hyperaudio}]
var promises = ajax.call([{
    methodname: 'mod_hyperaudio_load_timeline_comments',
    args:{
        'hyperaudio_id': hyperaudio_id,
        'duration': duration,
        'number_of_slots': number_of_slots
        }
    }]);
promises[0].done(function(data) {
    var container_height =
        $(".hyperaudio_timeline_blocks_container.comment_blocks_container").
            height();
		    	
    var pixel_width = 
        ((container_width - (number_of_slots-1)*2*2) / number_of_slots);
    var width = (pixel_width / (container_width + 20)) * 100;
    var height_1_comment = ((container_height - 5) / data.max_count);
		    	
    var output_comments = '';
    var output_notes = '';
    var height;
    var class_zero;
		    	
    function set_height_and_class(annotations){
        height = annotations * height_1_comment;
        if (height == 0){
            class_zero = 'block_zero';
        }
        else {
            class_zero = '';
        }
        if (height < 5){
            height = 5;
        }
    }
		    	
    function get_title(title, username){
        var result_title = '';
		    		
        if (username){
            result_title = username + ':\n';
        }
		    		
        if (title){
            if (title.length > 100){
                result_title = result_title + title.substr(0, 100) + " ...";
            }
            else {
                result_title = result_title + title;
            }
        }
		    		
        return result_title;
    }
		    	
    $(data.blocks).each(function(){
        set_height_and_class(this.comments);
        output_comments = output_comments + 
            '<div title="' + 
            get_title(this.title_comment_text, this.title_comment_username) +
            '" class="timeline_block comment_block ' + 
            class_zero + '" data-comment-id="' + 
            this.title_comment_id + 
            '" style="width: '+width+'%; height: ' + height + 'px;"
            onclick="jump_to_comment(this)"></div>';
                
        set_height_and_class(this.notes);
        output_notes = output_notes +
            '<div title="' +
            get_title(this.title_note_text) + 
            '" class="timeline_block note_block ' +
            class_zero + '" data-comment-id="' +
            this.title_note_id + 
            '" style="width: '+width+'%; height: ' +	height + 'px;"
            onclick="jump_to_comment(this)"></div>';
    });
    $(".hyperaudio_timeline_blocks.comment_blocks").html(output_comments);
    $(".hyperaudio_timeline_blocks.note_blocks").html(output_notes);
});
\end{lstlisting}
Beim Klick auf einen Block wird mit der Funktion \texttt{jump\underline{{ }}to\underline{{ }}comment} zu dem Kommentar gesprungen, welcher im Tooltip dargestellt wird. Selbiges gilt für Notizen. Hierbei müssen, wie in Auflistung \ref{lst:it9:locallib.js} zu sehen, auch Standard-Moodle-Elemente (Titelleiste) berücksichtigt werden, um die korrekte Stelle zu ermitteln, zu der gesprungen werden muss.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{locallib.js} in der 9. Iteration},
             label={lst:it9:locallib.js}]
function jump_to_comment(element){
    var comment_id = $(element).attr("data-comment-id");
	
    if (comment_id != "null"){
        $('html, body').animate({
            scrollTop:
                $('.comment[data-comment_id="' + comment_id + '"]').offset().top
                - $(".fixed-top.navbar").outerHeight()
        },'slow');
    }
}
\end{lstlisting}
Als Ergebnis dieser Iteration ergibt sich eine in die Mediensteuerung integrierte Visualisierung der Kommentare und Notizen, welche nicht nur der Übersicht sondern auch der Navigation dient.

\todo[inline]{SQL?}

\subsection{Lesezeichen}
Um die Vorstellung aus Abschnitt \ref{sub:Mediensteuerung} zu vervollständigen müssen nun noch die Lesezeichen in die Mediensteuerung integriert werden. Dementsprechend wird in dieser Iteration das Erstellen und Visualisieren von Lesezeichen behandelt.

In die vorhandenen Bedienelemente des \textit{VideoJS Players} wird eine weitere Schaltfläche zum Erstellen von Lesezeichen integriert (vgl. Auflistung \ref{lst:it10:hyperaudio.js}).

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{hyperaudio.js} in der 10. Iteration},
             label={lst:it10:hyperaudio.js}]
$(".vjs-volume-panel").after(
    '<button class="vjs-bookmark-control vjs-control vjs-button"
    type="button" title="' + string_bookmark + '"
    aria-disabled="false">' +
    '<span aria-hidden="true" class="far fa-bookmark vjs-icon-placeholder"></span>
    <span class="vjs-control-text" aria-live="polite">' + string_bookmark + '</span>
    </button>'
);
\end{lstlisting}

Das Speichern der Lesezeichen erfolgt nach Betätigung der Schaltfläche analog zum Speichern der Kommentare (vgl. Abschnitt \ref{sub:SpeichernKommentare}). Zur Darstellung der Lesezeichen wird die Funktion \texttt{show\underline{{ }}timeline} aus der \textbf{hyperaudio.js} erweitert sowie ein neuer Webservice für das Laden von Lesezeichen eingeführt. Der Webservice liefert der \texttt{show\underline{{ }}timeline}-Funktion die Lesezeichen des aktuellen Benutzers. Ihre Position innerhalb der Timeline ist durch einen prozentualen Abstand von links festgelegt, wobei sich der Prozentsatz gemäß Auflistung \ref{lst:it10:hyperaudio.js} durch das Verhältnis des Annotationszeitpunktes zur Abspieldauer ergibt. 

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{hyperaudio.js} in der 10. Iteration},
             label={lst:it10:hyperaudio.js}]
promises[1].done(function(data) {
    var output = '';
    $(data).each(function(){
    var left = (this.timeannotated / parseFloat(duration)) * 100;
    output = output + '<div title="' + string_delete_bookmark + '" 
        class="bookmark" style="left: ' + left + '%;" 
        data-comment_id="' + this.id +'">
        <i class="far fa-bookmark"/></div>';
    });
    $(".hyperaudio_timeline_bookmarks_container").html(output);
});
\end{lstlisting}

Mit einem Rechtsklick auf ein Lesezeichen wird die Löschung mit derselben Prozedur wie bei den Notizen abgearbeitet (vgl. Abschnitt \ref{sub:notizen}). Somit ist mit dieser Iteration auch das Erstellen, Anzeigen und Löschen von Lesezeichen möglich und die Implementierung der Mediensteuerung abgeschlossen. Die visuelle Umsetzung ist Abbildung \ref{fig:Mediensteuerung} zu entnehmen.


\begin{figure}[h!]
\includegraphics[width=\textwidth,center]{Mediensteuerung.png}
\caption{\label{fig:Mediensteuerung}Darstellung der Mediensteuerung}
\end{figure}


\subsection{Suche, Filter und Sortierung bei Kommentaren}
Die elfte Iteration beschäftigt sich mit den gewünschten Such-, Filter- und Sortierungsmöglichkeiten innerhalb der Kommentare und Notizen.

Dafür werden ein Eingabefeld, zwei Checkboxen und ein Dropdown-Menü in der \textbf{renderer.php} ergänzt. Die Filterung und Sortierung der Daten erfolgt mithilfe eines SQL-Statements, welches der Auflistung \ref{lst:it11:external} zu entnehmen ist. Die einzelnen Funktionen werden wie folgt umgesetzt:

\begin{itemize}
\item \textbf{Filter}\\
zusätzliche \texttt{WHERE}-Bedingung (Zeile 13):\\
\texttt{comments.comment_type IN (:p_filter_comment, :p_filter_note)}\\
Die Bindevariablen enthalten den jeweiligen Kommentar-Typ, falls dieser angezeigt werden soll und sind sonst leer (vgl. Zeilen 41-42).
\item \textbf{Suche}\\
zusätzliche \texttt{WHERE}-Bedingung (Zeile 14):\\
\texttt{\$DB->sql_like('comments.commenttext', ':p_search_string')}\\
Mithilfe der Funktion \texttt{sql_like} kann überprüft werden, ob der Kommentar den eingegebenen Suchbegriff enthält (vgl. Zeile 43).
\item \textbf{Sortierung}\\
verschiedene \texttt{ORDER BY}-Clauses abhängig von der gewählten Sortierreihenfolge (Zeilen 16-35)\\
Die drei verschiedenen Kriterien werden in entsprechender Reihenfolge angewandt:
\begin{itemize}
\item Annotationszeitpunkte
\item Erstellungszeitpunkte der Original-Kommentare
\item Erstellungszeitpunkte der Antwort-Kommentare
\end{itemize}
\end{itemize}

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{external.php} in der 11. Iteration},
             label={lst:it11:external}]
$sql='SELECT comments.id, comments.comment_type, comments.commenttext,'.
    ' comments.timeannotated, comments.timecreated,'.
    ' user.username, comments.comment_id'.
    ' FROM mdl_hyperaudio_comments comments'.
    ' INNER JOIN mdl_user user ON comments.userid = user.id'.
    ' LEFT JOIN mdl_hyperaudio_comments original_comment'.
    ' ON original_comment.id = comments.comment_id'.
    ' WHERE comments.hyperaudio_id = :p_hyperaudio_id'.
    ' AND (comments.comment_type = :p_comment_type_c'.
    ' OR (comments.comment_type = :p_comment_type_note'.
    ' AND comments.userid = :p_userid))'.
    ' AND comments.comment_type'.
    ' IN (:p_filter_comment, :p_filter_note)'.
    ' AND ' . $DB->sql_like('comments.commenttext', ':p_search_string');

switch ($order){
    case timecreated_asc:
        $sql.= 
            'ORDER BY
            IFNULL(original_comment.timecreated, comments.timecreated) asc,
            comments.timecreated asc';
        break;
    case timecreated_desc:
        $sql.= 
            'ORDER BY
            IFNULL(original_comment.timecreated, comments.timecreated) desc,
            comments.timecreated asc';
        break;
    case timeannotated:
        $sql.=
            'ORDER BY comments.timeannotated asc,
            IFNULL(original_comment.timecreated, comments.timecreated) asc,
            comments.timecreated asc';
        break;
}
        
$comments = $DB->get_records_sql($sql, array('p_hyperaudio_id' => $hyperaudio_id,
    'p_comment_type_c' => CommentType::Comment,
    'p_comment_type_note' => CommentType::Note,
    'p_userid' => $USER->id,
    'p_filter_comment' => $filter_comments ? CommentType::Comment : null,
    'p_filter_note' => $filter_notes ? CommentType::Note : null,
    'p_search_string' => '%' . $DB->sql_like_escape($search_string) . '%'));
\end{lstlisting}

Die Umsetzung der Such-, Filter- und Sortierfunktion runden die Implementierung der Wiedergabe von Hyperaudio-Dokumenten mit Kommunikations- und Interaktionsmöglichkeiten ab.

%%%%%%%%%%
\subsection{Unterstützung mobiler Endgeräte}
In der letzten Iteration werden Anpassungen vorgenommen, um die Nutzung des Hyperaudio-Plugins auch auf mobilen Endgeräte zu ermöglichen. Dafür werden wie bereits in Abschnitt \ref{sub:mobile} beschrieben Breakpoints eingeführt um die Anordnung der Elemente für mobile Endgeräte zu optimieren.

Durch den ersten Breakpoint weren die Bereiche, wie in Abbildung \ref{fig:BereicheDesktopMobile} sichtbar, neu angeordnet, so dass die Galerie sich nun unterhalb der Kommentare und Notizen befindet. Hierdurch wird der geringeren Bildschirmgröße der mobilen Endgeräte Sorge getragen.

\begin{figure}[h!]
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.95\textwidth,center]{BereicheDesktop.pdf}
\label{fig:BereicheDesktop}
\end{subfigure}%
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.6\textwidth,center]{BereicheMobile.pdf}
\label{fig:BereicheMobile}
\end{subfigure}
\caption{Darstellung der Bereiche für Desktop und mobile Endgeräte}
\label{fig:BereicheDesktopMobile}
\end{figure}

Ein weiterer Breakpoint wird bei der Such-, Filter- und Sortierfunktion angewandt, diese werden für mobile Endgeräte untereinander, statt nebeneinander angeordnet (siehe Abbildung \ref{fig:FilterDesktopMobile}).

\begin{figure}[h!]
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.95\textwidth,center]{FilterDesktop.pdf}
\label{fig:FilterDesktop}
\end{subfigure}%
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.6\textwidth,center]{FilterMobile.pdf}
\label{fig:FilterMobile}
\end{subfigure}
\caption{Darstellung der Such-, Filter- und Sortierfunktion für Desktop und mobile Endgeräte}
\label{fig:FilterDesktopMobile}
\end{figure}

Um auch innerhalb der Galerie auf die Gegebenheiten von mobilen Endgeräten Rücksicht zu nehmen, wird ein weiterer Breakpoint eingeführt. Dieser sorgt dafür, dass die Metainformationen der Zusatzinhalt unterhalb statt neben des Thumbnail dargestellt werden. Hieraus resultiert die in Abbildung \ref{fig:GalerieDesktopMobile} dargestellte Aufteilung.

\begin{figure}[h!]
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.95\textwidth,center]{GalerieDesktop.pdf}
\label{fig:GalerieDesktop}
\end{subfigure}%
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.6\textwidth,center]{GalerieMobile.pdf}
\label{fig:GalerieMobile}
\end{subfigure}
\caption{Darstellung der Galerie für Desktop und mobile Endgeräte}
\label{fig:GalerieDesktopMobile}
\end{figure}

Umgesetzt werden diese Breakpoints innerhalb der \textbf{styles.css}. Das Vorgehen ist in Auflistung \ref{lst:it12:styles} dargestellt. Es ist zu erkennen, dass die Darstellung der Desktop-Version mittels einer \texttt{@media} Abfrage unter der Angabe einer Mindestbreite vorgenommen wird. Sofern diese Bedingung nicht erfüllt wird, wird die Darstellung für die mobilen Endgeräte durchgeführt.

\begin{lstlisting}[language=php,
             linewidth=\textwidth,
             caption={Ausschnitt der \textbf{styles.css} in der 12. Iteration},
             label={lst:it12:styles}]
@media (min-width: 100em) {
  div#hyperaudio {
    display: grid;
    grid-template-columns: 70em 1fr;
  }
  div#gallery_container {
    margin-left: 2em;
  }
}

@media (min-width: 40em) {
  div.gallery_additional_content {
    display: grid;
    grid-template-columns: 1fr 5fr;
  }
}

@media (min-width: 50em) {
  div#comment_tools_container {
    display: grid;
    grid-template-columns: 4fr 2fr 3fr;
  }
  input#hyperaudio_search {
  	max-width: 35em;
  	margin-top: 0em;
  }
  div#comment_tools_filter,
  div#comment_tools_order {
  	display: flex;
    justify-content: flex-end;
    margin-left: 20px;
  }
}

div.gallery_additional_content {
    margin-bottom: 15px;
    padding: 5px 10px;
    border-radius: 10px;
}

div#comment_tools_container {
	align-items: baseline;
    margin-top: 1rem;
    max-width: 70em;
}

input#hyperaudio_search {
    font-family: Arial, FontAwesome;
    font-weight: normal;
    padding: 5px 10px;
    border: 1px solid lightgray;
    border-radius: 20px;
    width: 100%;
    margin-top: 0.3em;
}

div#comment_tools_order {
    align-items: baseline;
}
\end{lstlisting}
\todo[inline]{Styling anpassen und Code auf Aktualität prüfen}

%%%%%%%%%%
\section{Zusammenfassung}
Nachdem zu Beginn der Implementierung die grundlegende Moodle-Struktur erarbeitet wurde, wurden in den darauffolgenden Iterationen das Hyperaudio-Plugin Schritt für Schritt um die einzelnen Anforderungen erweitert. Somit ist am Ende die in Abbildung \ref{fig:DesktopFinal} sichtbar finale Repräsentation von Kurseinheiten als Hyperaudio-Dokumente innerhalb eines Moodle-Plugins entstanden. In der letzten Iteration wurde dann noch die Darstellung auf mobilen Endgeräten implementiert.
\begin{figure}[h!]
\includegraphics[width=\textwidth,center]{Desktop.png}
\caption{\label{fig:DesktopFinal}Darstellung der finalen Desktop-Version}
\end{figure}